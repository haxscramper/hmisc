<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>src/hmisc/algo/htree_mapping</title>
<link rel="stylesheet" type="text/css" href="../../nimdoc.out.css">

<script type="text/javascript" src="../../dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  if (toggleSwitch !== null) {
    toggleSwitch.addEventListener('change', switchTheme, false);
  }

  var currentTheme = localStorage.getItem('theme');
  if (!currentTheme && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    currentTheme = 'dark';
  }
  if (currentTheme) {
    document.documentElement.setAttribute('data-theme', currentTheme);

    if (currentTheme === 'dark' && toggleSwitch !== null) {
      toggleSwitch.checked = true;
    }
  }
}

window.addEventListener('DOMContentLoaded', main);
</script>

</head>
<body>
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">src/hmisc/algo/htree_mapping</h1>
    <div class="row">
  <div class="three columns">
  <div class="theme-switch-wrapper">
    <label class="theme-switch" for="checkbox">
      <input type="checkbox" id="checkbox" />
      <div class="slider round"></div>
    </label>
    &nbsp;&nbsp;&nbsp; <em>Dark Mode</em>
  </div>
  <div id="global-links">
    <ul class="simple">
    <li>
      <a href="../../theindex.html">Index</a>
    </li>
    </ul>
  </div>
  <div id="searchInputDiv">
    Search: <input type="text" id="searchInput"
      onkeyup="search()" />
  </div>
  <div>
    Group by:
    <select onchange="groupBy(this.value)">
      <option value="section">Section</option>
      <option value="type">Type</option>
    </select>
  </div>
  <ul class="simple simple-toc" id="toc-list">
<ul class="simple"><li><a class="reference" id="parameters_toc" href="#parameters">Parameters</a></li>
<li><a class="reference" id="parameters_toc" href="#parameters">Parameters</a></li>
<li><a class="reference" id="injected-variables_toc" href="#injected-variables">Injected variables</a></li>
<li><a class="reference" id="example_toc" href="#example">Example</a></li>
<li><a class="reference" id="parameters_toc" href="#parameters">Parameters</a></li>
<li><a class="reference" id="injected-variables_toc" href="#injected-variables">Injected variables</a></li>
</ul><li>
  <a class="reference reference-toplevel" href="#7" id="57">Types</a>
  <ul class="simple simple-toc-section">
      <li><a class="reference" href="#DfsTraversalOrder"
    title="DfsTraversalOrder = enum
  dfsPreorder, ## Preorder DFS traversal - first visit root node, and
                ## then all it's descendants.
  dfsPostorder,             ## First visit all child nodes and then root node
  dfsInorder                 ## Visit 'left' nodes, root and then 'right'.">DfsTraversalOrder</a></li>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#12" id="62">Procs</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">mapDFSpost
      <li><a class="reference" href="#mapDFSpost%2CInTree%2Cproc%28InTree%2Cseq%5Bint%5D%2Cseq%5BOutTree%5D%2Cseq%5BInTree%5D%29%2Cproc%28InTree%29%2Cproc%28InTree%29%2Cseq%5Bint%5D"
    title="mapDFSpost[InTree, OutTree, CbRes](tree: InTree; map: proc (n: InTree;
    path: seq[int]; subn: seq[OutTree]; inSubn: seq[InTree]): CbRes; getSubnodes: proc (
    tree: InTree): seq[InTree]; hasSubnodes: proc (it: InTree): bool = (proc (
    it: InTree): bool =
  true); path: seq[int] = @[0]): CbRes">mapDFSpost[InTree, OutTree, CbRes](tree: InTree; map: proc (n: InTree;
    path: seq[int]; subn: seq[OutTree]; inSubn: seq[InTree]): CbRes; getSubnodes: proc (
    tree: InTree): seq[InTree]; hasSubnodes: proc (it: InTree): bool = (proc (
    it: InTree): bool =
  true); path: seq[int] = @[0]): CbRes</a></li>
  <li><a class="reference" href="#mapDFSpost%2CInTree%2Cproc%28InTree%2Cseq%5BOutTree%5D%29%2Cproc%28InTree%29%2Cproc%28InTree%29%2Cseq%5Bint%5D_2"
    title="mapDFSpost[InTree, OutTree](tree: InTree;
                            map: proc (n: InTree; subn: seq[OutTree]): OutTree;
                            getSubnodes: proc (tree: InTree): seq[InTree];
    hasSubnodes: proc (it: InTree): bool = (proc (it: InTree): bool =
  true); path: seq[int] = @[0]): OutTree">mapDFSpost[InTree, OutTree](tree: InTree;
                            map: proc (n: InTree; subn: seq[OutTree]): OutTree;
                            getSubnodes: proc (tree: InTree): seq[InTree];
    hasSubnodes: proc (it: InTree): bool = (proc (it: InTree): bool =
  true); path: seq[int] = @[0]): OutTree</a></li>
  <li><a class="reference" href="#mapDFSpost%2CInTree%2Cproc%28InTree%2Cseq%5BOutTree%5D%29%2Cproc%28InTree%29%2Cproc%28InTree%29%2Cseq%5Bint%5D"
    title="mapDFSpost[InTree, OutTree](tree: InTree; map: proc (n: InTree;
    subn: seq[OutTree]): Option[OutTree];
                            getSubnodes: proc (tree: InTree): seq[InTree];
    hasSubnodes: proc (it: InTree): bool = (proc (it: InTree): bool =
  true); path: seq[int] = @[0]): Option[OutTree]">mapDFSpost[InTree, OutTree](tree: InTree; map: proc (n: InTree;
    subn: seq[OutTree]): Option[OutTree];
                            getSubnodes: proc (tree: InTree): seq[InTree];
    hasSubnodes: proc (it: InTree): bool = (proc (it: InTree): bool =
  true); path: seq[int] = @[0]): Option[OutTree]</a></li>

  </ul>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#17" id="67">Macros</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">mapItDFS
      <li><a class="reference" href="#mapItDFS.m%2Cuntyped%2Cuntyped%2Cuntyped%2Cuntyped%2Cuntyped"
    title="mapItDFS(inTree, subnodeCall, outType, hasSubnodes, op: untyped): untyped">mapItDFS(inTree, subnodeCall, outType, hasSubnodes, op: untyped): untyped</a></li>

  </ul>

  </ul>
</li>
<li>
  <a class="reference reference-toplevel" href="#18" id="68">Templates</a>
  <ul class="simple simple-toc-section">
      <ul class="simple nested-toc-section">iterateItBFS
      <li><a class="reference" href="#iterateItBFS.t%2Ctyped%2Cuntyped%2Cuntyped%2Cuntyped"
    title="iterateItBFS(topNode: typed; subNode: untyped; hasSubnodes: untyped;
             body: untyped): untyped">iterateItBFS(topNode: typed; subNode: untyped; hasSubnodes: untyped;
             body: untyped): untyped</a></li>
  <li><a class="reference" href="#iterateItBFS.t%2Cuntyped%2Cuntyped"
    title="iterateItBFS(tree, body: untyped): untyped">iterateItBFS(tree, body: untyped): untyped</a></li>

  </ul>
  <ul class="simple nested-toc-section">iterateItDFS
      <li><a class="reference" href="#iterateItDFS.t%2Cuntyped%2Cuntyped%2Cuntyped%2CDfsTraversalOrder%2Cuntyped"
    title="iterateItDFS(inTree, getSubnodes, hasSubnodes: untyped;
             order: DfsTraversalOrder; body: untyped): untyped">iterateItDFS(inTree, getSubnodes, hasSubnodes: untyped;
             order: DfsTraversalOrder; body: untyped): untyped</a></li>
  <li><a class="reference" href="#iterateItDFS.t%2Cuntyped%2Cuntyped%2Cuntyped"
    title="iterateItDFS(tree, orderOrGetKind, body: untyped): untyped">iterateItDFS(tree, orderOrGetKind, body: untyped): untyped</a></li>

  </ul>
  <ul class="simple nested-toc-section">mapItBFStoSeq
      <li><a class="reference" href="#mapItBFStoSeq.t%2Ctyped%2Cuntyped%2Cuntyped%2Cuntyped"
    title="mapItBFStoSeq(topNode: typed; subNode: untyped; op: untyped;
              hasSubnodes: untyped = true): untyped">mapItBFStoSeq(topNode: typed; subNode: untyped; op: untyped;
              hasSubnodes: untyped = true): untyped</a></li>

  </ul>
  <ul class="simple nested-toc-section">mapItDFSImpl
      <li><a class="reference" href="#mapItDFSImpl.t%2CInTree%2Cuntyped%2Cuntyped%2Cuntyped"
    title="mapItDFSImpl[InTree, OutTree](inTree: InTree; subnodeCall: untyped; op: untyped;
                              hasSubnodes: untyped = true): untyped">mapItDFSImpl[InTree, OutTree](inTree: InTree; subnodeCall: untyped; op: untyped;
                              hasSubnodes: untyped = true): untyped</a></li>

  </ul>

  </ul>
</li>

</ul>

  </div>
  &nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L1"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L1" class="link-seesrc" target="_blank" >Edit</a>

  <div class="nine columns" id="content">
  <div id="tocRoot"></div>
  
  <p class="module-desc">Generic implementations of algorithms for working with tree-like data structures. Iterative and recursive DFS/BFS with order control, recursive tree mapping etc.</p>
  <div class="section" id="7">
<h1><a class="toc-backref" href="#7">Types</a></h1>
<dl class="item">
<div id="DfsTraversalOrder">
<dt><pre><a href="htree_mapping.html#DfsTraversalOrder"><span class="Identifier">DfsTraversalOrder</span></a> <span class="Other">=</span> <span class="Keyword">enum</span>
  <span class="Identifier">dfsPreorder</span><span class="Other">,</span> <span class="Comment">## Preorder DFS traversal - first visit root node, and</span>
                <span class="Comment">## then all it's descendants.</span>
  <span class="Identifier">dfsPostorder</span><span class="Other">,</span>             <span class="Comment">## First visit all child nodes and then root node</span>
  <span class="Identifier">dfsInorder</span>                 <span class="Comment">## Visit 'left' nodes, root and then 'right'.</span></pre></dt>
<dd>

Order of traversal for DFS iteration. Nodes are ordered from left to right. This enum controls order in which elements will be 'acessed' (<tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> callback evaluated)
&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L316"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L316" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>

</dl></div>
<div class="section" id="12">
<h1><a class="toc-backref" href="#12">Procs</a></h1>
<dl class="item">
<div id="mapDFSpost,InTree,proc(InTree,seq[int],seq[OutTree],seq[InTree]),proc(InTree),proc(InTree),seq[int]">
<dt><pre><span class="Keyword">proc</span> <a href="#mapDFSpost%2CInTree%2Cproc%28InTree%2Cseq%5Bint%5D%2Cseq%5BOutTree%5D%2Cseq%5BInTree%5D%29%2Cproc%28InTree%29%2Cproc%28InTree%29%2Cseq%5Bint%5D"><span class="Identifier">mapDFSpost</span></a><span class="Other">[</span><span class="Identifier">InTree</span><span class="Other">,</span> <span class="Identifier">OutTree</span><span class="Other">,</span> <span class="Identifier">CbRes</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">tree</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">;</span> <span class="Identifier">map</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">;</span>
    <span class="Identifier">path</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">int</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">subn</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">OutTree</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">inSubn</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">InTree</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">CbRes</span><span class="Other">;</span> <span class="Identifier">getSubnodes</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span>
    <span class="Identifier">tree</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">InTree</span><span class="Other">]</span><span class="Other">;</span> <span class="Identifier">hasSubnodes</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">it</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">=</span> <span class="Other">(</span><span class="Keyword">proc</span> <span class="Other">(</span>
    <span class="Identifier">it</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">=</span>
  <span class="Identifier">true</span><span class="Other">)</span><span class="Other">;</span> <span class="Identifier">path</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">int</span><span class="Other">]</span> <span class="Other">=</span> <span class="Operator">@</span><span class="Other">[</span><span class="DecNumber">0</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">CbRes</span></pre></dt>
<dd>

<p>Map one tree into another</p>
<p>Convert one tree type into another using post-order DFS traversal. Tree is iterated in bottom-up manner. After leaving each node <tt class="docutils literal"><span class="pre"><span class="Identifier">map</span></span></tt> is called to generate new result. <tt class="docutils literal"><span class="pre"><span class="Identifier">subn</span></span></tt> is a result of previous.</p>
<p>For tree like this <tt class="docutils literal"><span class="pre"><span class="Identifier">map</span></span></tt> will first be executed for <tt class="docutils literal"><span class="pre"><span class="Identifier">IN1</span><span class="Operator">.</span><span class="DecNumber">1</span></span></tt> through <tt class="docutils literal"><span class="pre"><span class="Identifier">IN1</span><span class="Operator">.</span><span class="DecNumber">3</span></span></tt>. Results of the map will be passed as <tt class="docutils literal"><span class="pre"><span class="Identifier">subn</span></span></tt>.</p>
<pre class="listing">+-------+     +-------+     +-------+
| IN1.3 | &lt;-- |  IN1  | --&gt; | IN1.1 |
+-------+     +-------+     +-------+
                |
                |
                v
              +-------+
              | IN1.2 |
              +-------+</pre>
<h2><a class="toc-backref" id="parameters" href="#parameters">Parameters</a></h2><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">tree:</th><td>Input tree</td></tr>
<tr><th class="docinfo-name">map:</th><td><p>Procedure for converting one tree into another.</p>
<p><tt class="docutils literal"><span class="pre"><span class="Identifier">CbRes</span></span></tt> can be either <tt class="docutils literal"><span class="pre"><span class="Identifier">OutTree</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">Option</span><span class="Punctuation">[</span><span class="Identifier">OutTree</span><span class="Punctuation">]</span></span></tt>. In latter case <tt class="docutils literal"><span class="pre"><span class="Identifier">none</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt> results will be filtered out from the <tt class="docutils literal"><span class="pre"><span class="Identifier">subn</span></span></tt></p>
<table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">n:</th><td>Input subtree</td></tr>
<tr><th class="docinfo-name">path:</th><td>Path of the current subtree in original node</td></tr>
<tr><th class="docinfo-name">subn:</th><td>Evaluation results from child nodes.</td></tr>
<tr><th class="docinfo-name">inSubn:</th><td>List of child nodes for original node.</td></tr>
</tbody></table><p>Elements in <tt class="docutils literal"><span class="pre"><span class="Identifier">subn</span></span></tt> and <tt class="docutils literal"><span class="pre"><span class="Identifier">inSubn</span></span></tt> are ordered identically: <tt class="docutils literal"><span class="pre"><span class="Identifier">subn</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span> <span class="Operator">==</span> <span class="Identifier">map</span><span class="Punctuation">(</span><span class="Identifier">inSubn</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Operator">...</span><span class="Punctuation">)</span></span></tt></p>
</td></tr>
<tr><th class="docinfo-name">getSubnodes:</th><td>Get subnodes from current tree</td></tr>
<tr><th class="docinfo-name">hasSubnodes:</th><td>Check if input node can have subnodes</td></tr>
</tbody></table>
&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L159"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L159" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>
<div id="mapDFSpost,InTree,proc(InTree,seq[OutTree]),proc(InTree),proc(InTree),seq[int]_2">
<dt><pre><span class="Keyword">proc</span> <a href="#mapDFSpost%2CInTree%2Cproc%28InTree%2Cseq%5BOutTree%5D%29%2Cproc%28InTree%29%2Cproc%28InTree%29%2Cseq%5Bint%5D_2"><span class="Identifier">mapDFSpost</span></a><span class="Other">[</span><span class="Identifier">InTree</span><span class="Other">,</span> <span class="Identifier">OutTree</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">tree</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">;</span> <span class="Identifier">map</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">;</span>
    <span class="Identifier">subn</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">OutTree</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">OutTree</span><span class="Other">;</span> <span class="Identifier">getSubnodes</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">tree</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">InTree</span><span class="Other">]</span><span class="Other">;</span>
    <span class="Identifier">hasSubnodes</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">it</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">=</span> <span class="Other">(</span><span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">it</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">=</span>
  <span class="Identifier">true</span><span class="Other">)</span><span class="Other">;</span> <span class="Identifier">path</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">int</span><span class="Other">]</span> <span class="Other">=</span> <span class="Operator">@</span><span class="Other">[</span><span class="DecNumber">0</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">OutTree</span></pre></dt>
<dd>

Overload without <tt class="docutils literal"><span class="pre"><span class="Identifier">path</span></span></tt> for <tt class="docutils literal"><span class="pre"><span class="Identifier">map</span></span></tt>
&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L283"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L283" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>
<div id="mapDFSpost,InTree,proc(InTree,seq[OutTree]),proc(InTree),proc(InTree),seq[int]">
<dt><pre><span class="Keyword">proc</span> <a href="#mapDFSpost%2CInTree%2Cproc%28InTree%2Cseq%5BOutTree%5D%29%2Cproc%28InTree%29%2Cproc%28InTree%29%2Cseq%5Bint%5D"><span class="Identifier">mapDFSpost</span></a><span class="Other">[</span><span class="Identifier">InTree</span><span class="Other">,</span> <span class="Identifier">OutTree</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">tree</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">;</span> <span class="Identifier">map</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">n</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">;</span>
    <span class="Identifier">subn</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">OutTree</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">OutTree</span><span class="Other">]</span><span class="Other">;</span>
                                 <span class="Identifier">getSubnodes</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">tree</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">InTree</span><span class="Other">]</span><span class="Other">;</span>
    <span class="Identifier">hasSubnodes</span><span class="Other">:</span> <span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">it</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">=</span> <span class="Other">(</span><span class="Keyword">proc</span> <span class="Other">(</span><span class="Identifier">it</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">bool</span> <span class="Other">=</span>
  <span class="Identifier">true</span><span class="Other">)</span><span class="Other">;</span> <span class="Identifier">path</span><span class="Other">:</span> <span class="Identifier">seq</span><span class="Other">[</span><span class="Identifier">int</span><span class="Other">]</span> <span class="Other">=</span> <span class="Operator">@</span><span class="Other">[</span><span class="DecNumber">0</span><span class="Other">]</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">Option</span><span class="Other">[</span><span class="Identifier">OutTree</span><span class="Other">]</span></pre></dt>
<dd>

Map @param{InTree} to @param{OutTree} using @arg{map} for node conversion.<ul class="simple"><li>@arg{tree} :: Input tree structure</li>
<li>@arg{map} :: Conversion proc for subnodes.<ul class="simple"><li>@arg{n} :: Input tree node</li>
<li>@arg{subn} :: Sequence of already converted subnodes</li>
<li>@ret{} :: Return new node with all subnodes added. If original @arg{n} does not map into any node in new tree might return <tt class="docutils literal"><span class="pre"><span class="Identifier">none</span><span class="Punctuation">(</span><span class="Punctuation">)</span></span></tt></li>
</ul>
</li>
<li>@arg{getSubnodes} :: Return sequence of child nodes for @arg{tree}</li>
<li>@arg{hasSubnodes} :: Check if tree node has subnodes. Defaults to always-true. Override is necessary for cases where @arg{getSubnodes} can raise on invalid node kind (instead of returning empty sequence)</li>
<li>@arg[internal]{path} :: Path @arg{tree} in original tree.</li>
</ul>

&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L241"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L241" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>

</dl></div>
<div class="section" id="17">
<h1><a class="toc-backref" href="#17">Macros</a></h1>
<dl class="item">
<div id="mapItDFS.m,untyped,untyped,untyped,untyped,untyped">
<dt><pre><span class="Keyword">macro</span> <a href="#mapItDFS.m%2Cuntyped%2Cuntyped%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">mapItDFS</span></a><span class="Other">(</span><span class="Identifier">inTree</span><span class="Other">,</span> <span class="Identifier">subnodeCall</span><span class="Other">,</span> <span class="Identifier">outType</span><span class="Other">,</span> <span class="Identifier">hasSubnodes</span><span class="Other">,</span> <span class="Identifier">op</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

<p>Convert one tree type into another.</p>
<p>Conversion is perfomed in bottom-up manner - first child nodes are evaluated, then results are supplied to parent nodes and so on.</p>

<h2><a class="toc-backref" id="parameters" href="#parameters">Parameters</a></h2><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">subnodeCall:</th><td>Expression to get child nodes</td></tr>
<tr><th class="docinfo-name">outType:</th><td>Result type</td></tr>
<tr><th class="docinfo-name">inTree:</th><td>Tree to convert</td></tr>
<tr><th class="docinfo-name">op:</th><td>Expression for converting objects.</td></tr>
</tbody></table>
<h2><a class="toc-backref" id="injected-variables" href="#injected-variables">Injected variables</a></h2><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">it:</th><td>current tree node</td></tr>
<tr><th class="docinfo-name">path:</th><td>path of the current node in original tree</td></tr>
<tr><th class="docinfo-name">subt:</th><td>already converted subnodes</td></tr>
<tr><th class="docinfo-name">inSubt:</th><td>current input subnodes</td></tr>
</tbody></table>
<h2><a class="toc-backref" id="example" href="#example">Example</a></h2><p>For examples of use look into <tt class="docutils literal"><span class="pre"><span class="Identifier">tests</span><span class="Operator">/</span><span class="Identifier">tHalgorithm</span><span class="Operator">.</span><span class="Identifier">nim</span></span></tt>, 'Tree mapping suite'.</p>

&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L549"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L549" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>

</dl></div>
<div class="section" id="18">
<h1><a class="toc-backref" href="#18">Templates</a></h1>
<dl class="item">
<div id="iterateItBFS.t,typed,untyped,untyped,untyped">
<dt><pre><span class="Keyword">template</span> <a href="#iterateItBFS.t%2Ctyped%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">iterateItBFS</span></a><span class="Other">(</span><span class="Identifier">topNode</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">;</span> <span class="Identifier">subNode</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">hasSubnodes</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span>
                      <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Loop over tree nodes in BFS order
&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L111"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L111" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>
<div id="iterateItBFS.t,untyped,untyped">
<dt><pre><span class="Keyword">template</span> <a href="#iterateItBFS.t%2Cuntyped%2Cuntyped"><span class="Identifier">iterateItBFS</span></a><span class="Other">(</span><span class="Identifier">tree</span><span class="Other">,</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L149"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L149" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>
<div id="iterateItDFS.t,untyped,untyped,untyped,DfsTraversalOrder,untyped">
<dt><pre><span class="Keyword">template</span> <a href="#iterateItDFS.t%2Cuntyped%2Cuntyped%2Cuntyped%2CDfsTraversalOrder%2Cuntyped"><span class="Identifier">iterateItDFS</span></a><span class="Other">(</span><span class="Identifier">inTree</span><span class="Other">,</span> <span class="Identifier">getSubnodes</span><span class="Other">,</span> <span class="Identifier">hasSubnodes</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span>
                      <span class="Identifier">order</span><span class="Other">:</span> <a href="htree_mapping.html#DfsTraversalOrder"><span class="Identifier">DfsTraversalOrder</span></a><span class="Other">;</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Perform DFS iteration of the <tt class="docutils literal"><span class="pre"><span class="Identifier">inTree</span></span></tt> using <tt class="docutils literal"><span class="pre"><span class="Identifier">getSubnodes</span></span></tt> to get list of subnodes and <tt class="docutils literal"><span class="pre"><span class="Identifier">hasSubnodes</span></span></tt> to determine if particular node has subnodes.<ul class="simple"><li>Parameters</li>
</ul>
<table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">inTree:</th><td>First node in tree</td></tr>
<tr><th class="docinfo-name">getSubnodes:</th><td>Expression to get list of subnodes</td></tr>
<tr><th class="docinfo-name">hasSubnodes:</th><td>Expression to check if current node has list of subnodes</td></tr>
<tr><th class="docinfo-name">order:</th><td>Order of traversal</td></tr>
<tr><th class="docinfo-name">body:</th><td>Body to evaluate for each node</td></tr>
</tbody></table><ul class="simple"><li>Injected variables</li>
</ul>
<table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">it:</th><td>Current node</td></tr>
<tr><th class="docinfo-name">path:</th><td>Path to current node starting from the tree root</td></tr>
<tr><th class="docinfo-name">subt:</th><td>List of subnodes for current node</td></tr>
<tr><th class="docinfo-name">childIndex:</th><td>Index of child node. Can be used for inorder traversal to determine correct split on 'right' and 'left' nodes. For postorder traversal (and 'child' part of inorder) is equal to child count. For preorder - equal to 0.</td></tr>
</tbody></table><ul class="simple"><li>Notes</li>
</ul>
<ul class="simple"><li><p>NOTE :: inorder traversal is only well-defined for binary trees (e.g. when partitioning on 'left' and 'right' can be performed easyly). For all other cases you can use injected <tt class="docutils literal"><span class="pre"><span class="Identifier">childIndex</span></span></tt> - determine when 'middle' if the child list is reached and execute callback yourself. So most likely, for inorder traversal body should have form of</p>
<p><pre class="listing"><span class="Keyword">if</span> <span class="Identifier">childIndex</span> <span class="Operator">==</span> <span class="Identifier">it</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">div</span> <span class="DecNumber">2</span><span class="Punctuation">:</span>
      <span class="Comment"># execute actual callback</span>
  </pre></p>
</li>
</ul>
<p>or something similar (when last/first child is reached). Otherwise body will be executed each time traversal triggers 'between child nodes'.</p>
<ul class="simple"><li>TODO</li>
</ul>
<ul class="simple"><li>TODO :: Support iteration over mutable tree using pointers/references/view types or anything of that sort.</li>
</ul>

&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L328"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L328" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>
<div id="iterateItDFS.t,untyped,untyped,untyped">
<dt><pre><span class="Keyword">template</span> <a href="#iterateItDFS.t%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">iterateItDFS</span></a><span class="Other">(</span><span class="Identifier">tree</span><span class="Other">,</span> <span class="Identifier">orderOrGetKind</span><span class="Other">,</span> <span class="Identifier">body</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Perform iterative traversal of <tt class="docutils literal"><span class="pre"><span class="Identifier">tree</span></span></tt>, invoking <tt class="docutils literal"><span class="pre"><span class="Identifier">body</span></span></tt> for each node.<ul class="simple"><li>@arg{tree} :: Input tree</li>
<li>@arg{orderOrGetKind} :: Either <tt class="docutils literal"><span class="pre"><span class="Identifier">bool</span></span></tt> or <tt class="docutils literal"><span class="pre"><span class="Identifier">DfsTraversalOrder</span></span></tt> expression. <tt class="docutils literal"><span class="pre"><span class="Keyword">when</span> <span class="Keyword">is</span> <span class="Identifier">bool</span></span></tt>, used as predicate for checking if @injected{it} has subnodes. <tt class="docutils literal"><span class="pre"><span class="Identifier">dfsPreorder</span></span></tt> is then used as iteration order. When argument is of type <tt class="docutils literal"><span class="pre"><span class="Identifier">DfsTraversalOrder</span></span></tt> it is used as traversal order parameter, and <tt class="docutils literal"><span class="pre"><span class="Identifier">true</span></span></tt> is used for predicate.</li>
<li>@arg{body} :: Code block invoked on each node</li>
</ul>

&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L434"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L434" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>
<div id="mapItBFStoSeq.t,typed,untyped,untyped,untyped">
<dt><pre><span class="Keyword">template</span> <a href="#mapItBFStoSeq.t%2Ctyped%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">mapItBFStoSeq</span></a><span class="Other">(</span><span class="Identifier">topNode</span><span class="Other">:</span> <span class="Identifier">typed</span><span class="Other">;</span> <span class="Identifier">subNode</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">op</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span>
                       <span class="Identifier">hasSubnodes</span><span class="Other">:</span> <span class="Identifier">untyped</span> <span class="Other">=</span> <span class="Identifier">true</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>

Do BFS iteration on recursive data type and map results into sequence
<h2><a class="toc-backref" id="parameters" href="#parameters">Parameters</a></h2><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">topNode:</th><td>First node in tree</td></tr>
<tr><th class="docinfo-name">subNode:</th><td>Expression to get subnodes</td></tr>
<tr><th class="docinfo-name">op:</th><td>Expression to get result. If <tt class="docutils literal"><span class="pre"><span class="Identifier">typeof</span><span class="Punctuation">(</span><span class="Identifier">op</span><span class="Punctuation">)</span></span></tt> is <tt class="docutils literal"><span class="pre"><span class="Identifier">Option</span></span></tt> <tt class="docutils literal"><span class="pre"><span class="Identifier">none</span></span></tt> results are discarded</td></tr>
<tr><th class="docinfo-name">hasSubnode:</th><td>Check if particular node can have subnodes</td></tr>
</tbody></table>
<h2><a class="toc-backref" id="injected-variables" href="#injected-variables">Injected variables</a></h2><table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">it:</th><td>Current node in tree</td></tr>
<tr><th class="docinfo-name">lv:</th><td>level of current node in original tree</td></tr>
</tbody></table>
&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L39"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L39" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>
<div id="mapItDFSImpl.t,InTree,untyped,untyped,untyped">
<dt><pre><span class="Keyword">template</span> <a href="#mapItDFSImpl.t%2CInTree%2Cuntyped%2Cuntyped%2Cuntyped"><span class="Identifier">mapItDFSImpl</span></a><span class="Other">[</span><span class="Identifier">InTree</span><span class="Other">,</span> <span class="Identifier">OutTree</span><span class="Other">]</span><span class="Other">(</span><span class="Identifier">inTree</span><span class="Other">:</span> <span class="Identifier">InTree</span><span class="Other">;</span> <span class="Identifier">subnodeCall</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span>
                                       <span class="Identifier">op</span><span class="Other">:</span> <span class="Identifier">untyped</span><span class="Other">;</span> <span class="Identifier">hasSubnodes</span><span class="Other">:</span> <span class="Identifier">untyped</span> <span class="Other">=</span> <span class="Identifier">true</span><span class="Other">)</span><span class="Other">:</span> <span class="Identifier">untyped</span></pre></dt>
<dd>


&nbsp;&nbsp;<a
href="haxscramper/hmisc/tree/devel/src/hmisc/algo/htree_mapping.nim#L458"
class="link-seesrc" target="_blank">Source</a>
&nbsp;&nbsp;<a href="haxscramper/hmisc/edit/devel/src/hmisc/algo/htree_mapping.nim#L458" class="link-seesrc" target="_blank" >Edit</a>

</dd>
</div>

</dl></div>

  </div>
</div>

    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2021-11-27 16:51:25 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
